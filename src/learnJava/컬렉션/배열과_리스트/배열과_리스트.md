

## 배열 (Array)

### 특징
- 같은 자료형을 가진 변수를 하나로 나타낸 것
- 정의와 동시에 길이를 지정하며 길이를 바꿀 수 없다.
- 연속된 메모리 공간으로 이루어져 있다.
- 데이터 갯수가 확실하게 정해져 있고, 접근이 빈번한 경우 배열이 효율적이다.
- 삽입과 삭제의 경우 연속적인 형태 유지를 위해 shift 연산을 해야하므로 O(n)의 시간복잡도를 가진다.


### 장점
- 접근, 수정이 빠르다.
- 연속적인 메모리 공간으로 이루어져 있어, 메모리 관리가 편하다.
- `cache hit` 가능성이 크다.
> cache hit : CPU가 참조하고자 하는 메모리가 캐시에 존재하고 있는 경우

### 단점
- 데이터를 삭제해도, 연속적인 형태를 유지하기 위해 공간이 낭비되어 메모리가 낭비된다.
- 정적이므로, 컴파일 이전에 크기를 정해주어야 한다.
- 배열의 크기를 바꿀 수 없다.

---

## 리스트 (List)

### 특징
- 배열의 문제점을 해결하기 위한 자료구조
- 순서가 있는 데이터의 모임이다.
- 빈틈없는 데이터의 적재라는 장점을 가진다.
  - 원소 삭제시, 삭제된 데이터 뒤 원소들을 연속적으로 위치시킨다.
- `cache hit` 가능성이 낮다.

### 장점
- 포인터를 통하여 다음 데이터의 위치를 가르키고 있어 삽입, 삭제가 용이하다.
- 동적이므로 크기가 정해져 있지 않다.
- 메모리의 재사용이 편리하다.

### 단점
- 검색 성능이 좋지 않다.
- 불연속적이므로 메모리 관리가 편리함
- 포인터를 통해 다음 데이터를 가리키기 때문에 추가적인 메모리 공간이 발생함

---

## ArrayList
- 크기를 동적으로 늘릴 수 있다.
  - `기본 크기 private static final int DEFAULT_CAPACITY = 10;`
  - 저장한 용량 크기를 넘으면, 용량을 1.5배로 증가시킨다.
- 특정 위치의 원소에 대한 접근, 수정의 시간복잡도가 O(1)
- `AbstractList` 상속

## LinkedList
- 노드 간의 연결을 통해서 리스트로 구현된 객체이다.
- 순차접근만 가능하다. 특정 위치의 원소에 대한 접근, 수정의 시간복잡도 O(n)
  - 다음 노드의 위치 정보만 가지고 있고, 인덱스를 가지고 있지 않다.
    - 노드 탐색시 시간 소요가 많이 될 수 있다.
    - `Random access` 불가능
- 통상 원소 삽입의 시간복잡도가 ArrayList 와 같다고 표기되나, 실제로는 더 빠르다.
- `AbstractSequentialList` 상속